---
title: "Codeforces Round 641 Div 2"
date: 2020-05-12
---
{% include lib/mathjax.html %}

### Problem A: Orac and Factors

Given two numbers **N** and **K**, apply `f(N)` to **N** exactly **K** times, where `f(n)` is the smallest positive divisor of n except 1.

<details>
<summary>
Hint 1 
</summary>
<ul>
<li> After applying f(N) for the first time, what property do you observe on the result? </li>
</ul>
</details>

<details>
<summary>
Hint 2 
</summary>
<ul>
<li> After applying f once, the resulting number will be even, why? </li>
<li> If so, for the remaining (k - 1) times, 2 will be added to the result. </li>
</ul>
</details>

<details>
<summary>
Time Complexity
</summary>
$$\mathcal{O}(\sqrt{N})$$
</details>

<details>
<summary>
Code
</summary>
{% highlight c++ %}
typedef long long ll;
void solve() {
    ll n, k;
    cin >> n >> k;

    ll factor = 2;
    ll maxFactor = sqrt(n);
    while (factor <= maxFactor) {
        if (n % factor == 0) { // smallest factor except 1
            break;
        }
        ++factor;
    }
    if (n % factor != 0) { // no factor in [2, sqrt(n)], so f(n) = n
        factor = n;
    }

    ll res = n + factor + (k - 1)*2; // 2 for the remaining (k - 1) times
    cout << res << endl;
}
{% endhighlight %}
</details>

- - - 

### Problem B: Orac and Models

**Problem Statement:**

- You are given an array **arr** containing **n** elements. Find the maximum beautiful subsequence length.
- A subsequence of **arr** is beautiful, if for every adjacent elements, with indices $$i_{j}$$ and $$i_{j + 1}$$ in the array, where $$i_{j} < i_{j+1}$$, $$i_{j+1}$$ is divisible by $$i_{j}$$ and $$arr[i_{j}] < arr[i_{j+1}]$$.

<details>
<summary>
Hint 1
</summary>
<ul>
<li> What if you already knew the maximum subsequence length for all subarrays starting from 0 and ending till index (i-1)? </li>
<li> How will you find the answer for subarray starting from 0 and ending at index (i) ? </li>
</ul>
</details>

<details>
<summary>
Hint 2
</summary>
<ul>
<li> Well, what can be the previous index where you may pick an element in the subsequence? It must be a factor of i! </li>
<li> So, for all factors of i, say j, which can be computed in sqrt(n) time, see if arr[j] < arr[i] holds, then update answer for arr[0...i] by maximum of ans[i], ans[j] + 1. </li>
<li> See code for details. </li>
</ul>
</details>

<details>
<summary>
Time Complexity
</summary>
$$\mathcal{O}(N \sqrt{N})$$
</details>

<details>
<summary>
Code
</summary>
{% highlight c++ %}
typedef long long ll;
void solve() {
    ll n;
    cin >> n;
    vector<ll> arr(n + 1, 0);
    for (int i = 1; i <= n; ++i) {
        cin >> arr[i];
    }

    vector<ll> dp(n + 1, 0);
    ll res = 1;
    for (int i = 1; i <= n; ++i) {
        ll cur = 1;
        for (int j = 1; j <= sqrt(i); ++j) {
            if (i % j == 0 && arr[j] < arr[i]) {
                cur = max(cur, 1 + dp[j]);
            }
            if (i % j == 0 && arr[i/j] < arr[i]) {
                cur = max(cur, 1 + dp[i/j]);
            }
        }
        dp[i] = cur;
        res = max(res, dp[i]);
    }
    cout << res << endl;
}
{% endhighlight %}

</details>

- - -

### Problem C: Orac and LCM

**Problem Statement:**

- You are given an array **arr** containing **n** elements.
- Construct a multiset containing the lcm of all pairs of elements, say M.
- Find the gcd of all the elements in M.
- Note the constraints. So, $$\mathcal{O}(n^2)$$ solution won't work.

**Constraints:**

- $$ 2 \leq N \leq 10^5 $$
- $$ 1 \leq arr[i] \leq 2*10^5 $$

<details>
<summary>
Hints 
</summary>
<ul>
<li> Will be updated in 10 minutes.</li>
</ul>
</details>

<details>
<summary>
Code
</summary>
{% highlight c++ %}

{% endhighlight %}

</details>

- - -